<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-10-22T20:29:56+07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Dnomyar Space</title><subtitle>All things about QA, programming, life, and traces of meme.</subtitle><author><name>Raymond</name></author><entry><title type="html">Automatically Retrying Failed Karate Tests</title><link href="http://localhost:4000/karate/automated%20test/retry-failed-karate-tests/" rel="alternate" type="text/html" title="Automatically Retrying Failed Karate Tests" /><published>2020-10-22T00:00:00+07:00</published><updated>2020-10-22T00:00:00+07:00</updated><id>http://localhost:4000/karate/automated%20test/retry-failed-karate-tests</id><content type="html" xml:base="http://localhost:4000/karate/automated%20test/retry-failed-karate-tests/">&lt;h2 id=&quot;karate-tests-prep&quot;&gt;Karate Tests Prep&lt;/h2&gt;
&lt;p&gt;If you haven‚Äôt read through my article &lt;a href=&quot;https://dnomyar.dev/karate/automated%20test/karate-graphql&quot; target=&quot;_blank&quot;&gt;Powerful GraphQL Automated Test Using Karate&lt;/a&gt;, you should do that now. You will need to know how Karate test works firsthand before proceeding with this one. This post will walk you on how to automatically retry failed tests on karate.&lt;/p&gt;

&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;Karate is an awesome test automation library, there is no denying that. However it currently does not support auto retrying test cases that failed in the first execution. I am talking about something like &lt;a href=&quot;https://medium.com/@sonaldwivedi/how-to-rerun-only-failed-testcases-using-testng-a23802f6884&quot; target=&quot;_blank&quot;&gt;this&lt;/a&gt; via TestNG or &lt;a href=&quot;https://medium.com/@omurdenden/re-run-failed-automated-test-cases-in-robot-framework-jenkins-setup-5d293ea40947&quot; target=&quot;_blank&quot;&gt;this&lt;/a&gt; via RobotFramework. The closest available mean of retry in karate comes in form of &lt;a href=&quot;https://github.com/intuit/karate/releases/tag/v0.9.0&quot; target=&quot;_blank&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;retry until&lt;/code&gt;&lt;/a&gt; of which you need to put manually on all of your test cases.&lt;/p&gt;

&lt;p&gt;Personally I understand the reason behind this, as tests should be deterministic. However, while that might work out well in an ideal world; we run our test cases on staging environment (which is far cry from production environment). Sometimes test fail because of random things such as network condition, some services occassionally chug, and many other things.&lt;/p&gt;

&lt;p&gt;Our automated tests become too flaky. Considering that we put our tests as a mandatory pipeline to introduce code to staging, it is totally unacceptable having to re-run tests all the time. It becomes more frustrating when every times you re-run the tests, different causes of failure block the pipeline.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/karate-retry/bruh.jpeg&quot; alt=&quot;Meme&quot; title=&quot;Bruh&quot; height=&quot;75%&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/karate-retry/devops.jpg&quot; alt=&quot;Meme&quot; title=&quot;Bruh&quot; height=&quot;75%&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Somehow it turns into this kind of joke for us&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Oopsie, pretty sure it‚Äôs a pain in the ass and we want to avoid that.&lt;/p&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;

&lt;p&gt;I decided to do a research about karate hooks and remembered that you can actually implement karate‚Äôs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ExecutionHook&lt;/code&gt; and override each of the hooks:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;beforeScenario&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterScenario&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;beforeFeature&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterFeature&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;beforeAll&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterAll&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;beforeStep&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterStep&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPerfEventName&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reportPerfEvent&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Having previously played with these hooks in order to &lt;a href=&quot;https://dnomyar.dev/karate/automated%20test/graphql/auto-generate-grapql-queries-karate/&quot; target=&quot;_blank&quot;&gt;automatically generates GraphQL queries&lt;/a&gt;, I found out that it is also possible for us to retry tests utilizing one of these hooks.&lt;/p&gt;

&lt;p&gt;Particularly we can override &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;afterScenario&lt;/code&gt;. We can do these things:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@retry&lt;/code&gt; tag to failed tests&lt;/li&gt;
  &lt;li&gt;Retry the tests with tag &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@retry&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Delete the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@retry&lt;/code&gt; tag from the tests if they are now passing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Below is the code( You can find it along with the whole tests sample &lt;a href=&quot;https://github.com/dnomyar90/football-karate-demo-graphql/tree/master/qa&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    @Override
    public void afterScenario(ScenarioResult result, ScenarioContext context) {
        File f = null;
        f = context.rootFeatureContext.feature.getPath().toFile();
        String filePath = f.toString();
        int line = 0;
        Path path = Paths.get(filePath);

        if (result.isFailed()) {
            try {
                String annotation = Files.readAllLines(path).get(line);
                if (!annotation.contains(&quot;@retry&quot;)) {
                    List&amp;lt;String&amp;gt; lines = Files.readAllLines(path, StandardCharsets.UTF_8);
                    lines.add(line, &quot;@retry&quot;);
                    Files.write(path, lines, StandardCharsets.UTF_8);
                }

            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            try {
                Charset charset = StandardCharsets.UTF_8;
                String content = new String(Files.readAllBytes(path), charset);
                String pattern = &quot;@retry&quot;;
                content = content.replaceAll(pattern, &quot;&quot;);
                Files.write(path, content.getBytes(charset));
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And on the test runner part you can simply just do this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class TestRunner {
    @Test
    public void testParallel() throws Exception {
        String retryPath = System.getProperty(&quot;user.dir&quot;) + &quot;/target/test-classes/features&quot;;
        int retryCount = 3;
        // Run parallelly and retry according to retry count
        Results result = Runner.path(&quot;classpath:features&quot;).hook(new KarateExecutionHook()).tags(&quot;~@ignore&quot;)
                .parallel(10);

        if (result.getFailCount() &amp;gt; 0) {
            for (int i = 0; i &amp;lt; retryCount; i++) {
                System.out.println(&quot;====Retrying test====&quot;);
                result = Runner.path(retryPath).hook(new KarateExecutionHook()).tags(&quot;@retry&quot;,&quot;~@ignore&quot;).parallel(10);
                if(result.getFailCount() == 0)
                break;
            }
        }
        Assert.assertTrue(result.getErrorMessages(), result.getFailCount() == 0);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It is just simply a string manipulation where we append &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@retry&lt;/code&gt; tag to failed tests‚Äô generated files. Then re-run the tests with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@retry&lt;/code&gt; tag from that folder. Lastly, delete the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@retry&lt;/code&gt; tag if the tests are now passing. Below is an example of the retry process:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/karate-retry/pipe1.png&quot; alt=&quot;Pipe1&quot; title=&quot;Pipe1&quot; height=&quot;50%&quot; width=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- First run: Failed with 51 failing features (68 scenarios)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;*We are still running all the scenarios on the failing tests, hence on the next execution the number of scenarios we run is not 65 but 68&lt;/em&gt; ‚úåÔ∏è&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/karate-retry/pipe2.png&quot; alt=&quot;Pipe2&quot; title=&quot;Pipe2&quot; height=&quot;75%&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- Second run: Re-runing 68 failing scenarios. Now only 11 is still failing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/karate-retry/pipe3.png&quot; alt=&quot;Pipe3&quot; title=&quot;Pipe3&quot; height=&quot;75%&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- Last run: 11 remaining test is now passing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/karate-retry/iu.gif&quot; alt=&quot;Pipe1&quot; title=&quot;Pipe1&quot; height=&quot;75%&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Yeay test execution becomes less flaky. Everybody now have time to play Mobile Legends instead of anxiously waiting for test results.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;It is truly amazing how such simple tweak can save you from a lot of headache. And again this shows how adjustable karate is to your needs, you can do whatever you want with the provided features of the library. However this approach is far from perfect as it still re-runs all of the failing scenarios on a feature.&lt;/p&gt;

&lt;p&gt;For example if you have a test feature with 3 scenarios. Using this approach, even though there is only 1 failing scenario on that test feature, we still re-run all of the 3 cases. We are still exploring on how to tweak the approach to handle the re-run more efficiently ü§û&lt;/p&gt;

&lt;p&gt;That‚Äôs all for this post. I hope you can utilise the same (if not better) approach in order to make your test executions more reliable. Please do comment if you have something to ask for discuss (You need to login via FB first though).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Stay safe, stay healthy, and always wear your masks outside!&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;repository&quot;&gt;&lt;a href=&quot;https://github.com/dnomyar90/football-karate-demo-graphql/tree/master/qa&quot; target=&quot;_blank&quot;&gt;Repository&lt;/a&gt;&lt;/h1&gt;</content><author><name>Raymond</name></author><category term="karate" /><category term="automated test" /><category term="karate" /><category term="automated test" /><summary type="html">Make test execution less flaky by retrying (only) failed tests.</summary></entry><entry><title type="html">Reusing Fragments and Autogenerate GraphQL Queries Using Karate</title><link href="http://localhost:4000/karate/automated%20test/graphql/auto-generate-grapql-queries-karate/" rel="alternate" type="text/html" title="Reusing Fragments and Autogenerate GraphQL Queries Using Karate" /><published>2020-07-25T00:00:00+07:00</published><updated>2020-07-25T00:00:00+07:00</updated><id>http://localhost:4000/karate/automated%20test/graphql/auto-generate-grapql-queries-karate</id><content type="html" xml:base="http://localhost:4000/karate/automated%20test/graphql/auto-generate-grapql-queries-karate/">&lt;h2 id=&quot;karate-tests-prep&quot;&gt;Karate Tests Prep&lt;/h2&gt;
&lt;p&gt;If you haven‚Äôt read through my article &lt;a href=&quot;https://dnomyar.dev/karate/automated%20test/karate-graphql&quot; target=&quot;_blank&quot;&gt;Powerful GraphQL Automated Test Using Karate&lt;/a&gt;, you should do that now. You will need to know how Karate test works firsthand before proceeding with this one. This post will walk you through the workaround to organise your GraphQL queries and fragments using karate.&lt;/p&gt;

&lt;h2 id=&quot;problem-statement&quot;&gt;Problem Statement&lt;/h2&gt;
&lt;p&gt;As I have mentioned on my other &lt;a href=&quot;https://dnomyar.dev/karate/automated%20test/karate-graphql&quot; target=&quot;_blank&quot;&gt;article&lt;/a&gt;, karate is really great for either REST or &lt;a href=&quot;https://graphql.org/&quot;&gt;GraphQL&lt;/a&gt; requests. To be speicific in my current company (&lt;a href=&quot;https://kumparan.com/&quot;&gt;kumparan.com&lt;/a&gt;), we are dealing with GraphQL. GraphQL test automation is provided out of the box with karate. Based on the example on karate‚Äôs github, you can either use plain text or even read from GraphQL files.&lt;/p&gt;

&lt;p&gt;GraphQL request looks something like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;query FindAllPlayers {
FindAllPlayers {
...Player
}
}

fragment Player on Player {
id
first_name
last_name
team{
...Team
}
}

fragment Team on Team {
id
name
is_league_winner
current_competitions
league{
...League
}
}

fragment League on League {
id
name
continent
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AFAIK this is the standard way of doing things in tools like &lt;a href=&quot;https://www.postman.com/&quot;&gt;Postman&lt;/a&gt; or &lt;a href=&quot;https://insomnia.rest/&quot;&gt;Insomnia&lt;/a&gt;. We need to write each fragment again and again for each query. This generates two big concerns for me:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If a fragment is changed, we need to find and replace each fragment on each query&lt;/li&gt;
  &lt;li&gt;Writing queries to use in Postman or Insomnia will be a painful process&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;solution-for-problem-1&quot;&gt;Solution for problem #1&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;Problem #1&lt;/em&gt;&lt;/strong&gt;:
‚ÄúIf a fragment is changed, we need to find and replace each fragment on each query‚Äù&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We decided that we must design the usage of fragments and queries on our karate tests to be as modular as possible. We achieve our goal by separating fragments and queries. We declare them in their own specific javascript files. Karate really comes in handy as it can easily make javascript calls out of the box.&lt;/p&gt;

&lt;p&gt;We ended up using this kind of setup:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- feature files
  -- FindAllPlayers.feature
  -- FindPlayerByID.feature
  -- AddNewPlayer.feature
  -- ....
-- queries
  -- FindAllPlayers.js
  -- FindPlayerByID.js
  -- ....
-- mutations
  -- AddNewPlayer.js
  -- ....
   -- fragments
      -- FragmentPlayer.js
      -- FragmentLeague.js
      -- FragmentTeam.js
      -- ....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Each &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.feature&lt;/code&gt; is going to call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;queries&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mutations&lt;/code&gt;. On each &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;query&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mutation&lt;/code&gt; they are going to specify the operation to use and the fragments they need. Hence, no need for us to hardcode each fragment to every query or mutation.&lt;/p&gt;

&lt;p&gt;Below are the code implementation of the setup (which you can find in the &lt;a href=&quot;https://github.com/dnomyar90/football-karate-demo-graphql/tree/master/qa&quot; target=&quot;_blank&quot;&gt;repository&lt;/a&gt; too):&lt;/p&gt;
&lt;h3 id=&quot;feature-file&quot;&gt;Feature file&lt;/h3&gt;
&lt;p&gt;In feature file we call the javascript file for query or mutation. It is as simple as that.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@query
Feature: Test GraphQL Find Players

    Background:
        Given url baseUrl

    Scenario: Find All Players

      Given def query = karate.call('classpath:queries/FindAllPlayers.js')
      
      And request { query: '#(query)'}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;query-file&quot;&gt;Query file&lt;/h3&gt;
&lt;p&gt;Here we declare the query with all of it‚Äôs parameters. We call the fragments we need.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;helper.js&lt;/code&gt; is a string manipulation javascript file we use to &lt;em&gt;flatten&lt;/em&gt; the fragments. It works to avoid duplicated fragments to be declared (sometimes in complex requests we call a lot of fragments). Of course you can find it on the &lt;a href=&quot;https://github.com/dnomyar90/football-karate-demo-graphql/tree/master/qa&quot; target=&quot;_blank&quot;&gt;repository&lt;/a&gt; too.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function () {
    var query =
        'query FindAllPlayers {\
            FindAllPlayers {\
                    ...Player\
                }\
                }';

    var fragments = [
        karate.call('classpath:fragments/FragmentPlayer.js').Player()
    ];
    return karate.read('classpath:helper.js')(query, fragments);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;fragment-file&quot;&gt;Fragment file&lt;/h3&gt;
&lt;p&gt;Here we declare the smallest unit of all tests. Each fragment is declared in a modular fashion that we will return them in form of array. Hence, making it possible for us to reuse fragments from another files.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//FragmentPlayer.js
function() {
    var Player =
      'fragment Player on Player {\
        id\
        first_name\
        last_name\
        team{\
          ...Team\
        }\
     }';
  
    return {
      Player: function () { return [Player,
        karate.call('classpath:fragments/FragmentTeam.js').Team()
      ]
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//FragmentTeam.js
function() {
    var Team =
      'fragment Team on Team {\
        id\
        name\
        is_league_winner\
        current_competitions\
        league{\
          ...League\
        }\
     }';
  
    return {
      Team: function () { return [Team,
        karate.call('classpath:fragments/FragmentLeague.js').League()
      ]
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//FragmentLeague.js
function() {
    var League =
      'fragment League on League {\
        id\
        name\
        continent\
     }';
  
    return {
      League: function () { return [League]}
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By achieving this setup, we managed to avoid the dangerous part of hard coding fragments to each GraphQL requests. So far it is quite useful for us too in terms of making writing tests a simpler task. When we are about to write new tests with existing fragments, we can just call the existing fragments instead of writing all required fragments from scratch.&lt;/p&gt;

&lt;h2 id=&quot;solution-for-problem-2&quot;&gt;Solution for Problem #2&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;Problem #2&lt;/em&gt;&lt;/strong&gt;:
‚ÄúWriting queries to use in Postman or Insomnia will be a painful process‚Äù&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After using karate for GraphQL test automation for some time, we faced another problem (although it is unrelated with karate). We are testing GraphQL requests for new features or refactors using &lt;a href=&quot;https://insomnia.rest/&quot;&gt;Insomnia&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In Insomnia, like Postman, they have no &lt;em&gt;object-oriented-approach&lt;/em&gt; to reuse fragments. So we need to type in fragments all over again for all requests. This increasingly becomes annoying as it hampers productivity. Plus it becomes a risk since we might miss keying in some part of the fragments that may otherwise result in failure when called.&lt;/p&gt;

&lt;p&gt;After reading that in karate we can override embedded execution hook, we managed to auto generate all existing requests on karate tests so that we won‚Äôt need to key in all fragments manually again. It is really fascinating that karate provides both simplicity and at the same time possibility for us to dig deeper and toy around to cater our specific needs.&lt;/p&gt;

&lt;p&gt;So basically this is what we do with the test runner:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Intercept before requesting a query&lt;/li&gt;
  &lt;li&gt;Get the query/mutation name&lt;/li&gt;
  &lt;li&gt;Generate the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.graphql&lt;/code&gt; file for that query/mutation&lt;/li&gt;
  &lt;li&gt;Write the query/mutation content into that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.graphql&lt;/code&gt; file&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
    public boolean beforeStep(Step step, ScenarioContext context) {
        if (step.getText().trim().contains(&quot;request {&quot;)) {
            try {
                File dir = new File(&quot;GQL-Queries&quot;);
                dir.mkdirs();
                String rawQuery = context.vars.get(&quot;query&quot;).getValue().toString();
                String[] splittedQuery = rawQuery.split(&quot;\n&quot;, 2);
                String firstLineQuery = splittedQuery[0];
                String queryName = firstLineQuery.replace(&quot;query&quot;,&quot;&quot;).replace(&quot;mutation&quot;, &quot;&quot;).replaceAll(&quot;\\(.*?\\{&quot;, &quot;&quot;).replaceAll(&quot; &quot;,&quot;&quot;).replace(&quot;}&quot;,&quot;&quot;).replace(&quot;{&quot;,&quot;&quot;)+ &quot;.graphql&quot;;
                File file = new File(dir, queryName);
                FileWriter myWriter = new FileWriter(file);
                myWriter.write(context.vars.get(&quot;query&quot;).getValue().toString());
                myWriter.close();
              } catch (IOException e) {
                e.printStackTrace();
              }
        }
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The above file is available on &lt;a href=&quot;https://github.com/dnomyar90/football-karate-demo-graphql/tree/master/qa&quot; target=&quot;_blank&quot;&gt;repository&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The hook above will generate &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.graphql&lt;/code&gt; files for each request, even if you call multiple requests in a single &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.feature&lt;/code&gt; file. It generates file in the folder &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GraphQL-Queries&lt;/code&gt; after each exeuction:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/karate-gql/GQLFiles.png&quot; alt=&quot;GQLFiles&quot; title=&quot;GQLFiles&quot; height=&quot;75%&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can then reuse those &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.graphql&lt;/code&gt; files on Postman, Insomnia, or any other tools you use:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/karate-gql/FindAllPlayers.png&quot; alt=&quot;FindAllPlayers&quot; title=&quot;FindAllPlayers&quot; height=&quot;75%&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/karate-gql/AddNewPlayer.png&quot; alt=&quot;AddNewPlayer&quot; title=&quot;AddNewPlayer&quot; height=&quot;75%&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;With the approach above, it is more enjoyable now to test GraphQL requests since we don‚Äôt have to type requests manually. We just need to look into our &lt;a href=&quot;https://github.com/dnomyar90/football-karate-demo-graphql/tree/master/qa/GQL-Queries&quot; target=&quot;_blank&quot;&gt;collection&lt;/a&gt; or run our tests locally. Our karate tests now not only works well for automated test, but also help to increase our productivity when testing features/refactors üòÉ&lt;/p&gt;

&lt;p&gt;That‚Äôs it! Hope you find it useful.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Stay safe, stay healthy, and wear your masks!&lt;/em&gt; ‚úåÔ∏è&lt;/p&gt;

&lt;h1 id=&quot;repository&quot;&gt;&lt;a href=&quot;https://github.com/dnomyar90/football-karate-demo-graphql/tree/master/qa&quot; target=&quot;_blank&quot;&gt;Repository&lt;/a&gt;&lt;/h1&gt;</content><author><name>Raymond</name></author><category term="karate" /><category term="automated test" /><category term="graphql" /><category term="karate" /><category term="automated test" /><category term="graphql" /><summary type="html">Make your GraphQL testing more enjoyable. Autogenerate your GraphQL queries &amp; reuse fragments modularly straight from your automated tests!</summary></entry><entry><title type="html">Irritating Question: Are You An Automation Tester?</title><link href="http://localhost:4000/software%20testing/automated%20test/are-you-automation-tester/" rel="alternate" type="text/html" title="Irritating Question: Are You An Automation Tester?" /><published>2020-07-03T00:00:00+07:00</published><updated>2020-07-03T00:00:00+07:00</updated><id>http://localhost:4000/software%20testing/automated%20test/are-you-automation-tester</id><content type="html" xml:base="http://localhost:4000/software%20testing/automated%20test/are-you-automation-tester/">&lt;h2 id=&quot;the-question&quot;&gt;The Question&lt;/h2&gt;
&lt;h3 id=&quot;so-you-are-on-qa-are-you-an-automation-tester-or-just-a-tester&quot;&gt;‚ÄúSo you are on QA. Are you an automation tester or &lt;em&gt;just&lt;/em&gt; a tester?‚Äù&lt;/h3&gt;

&lt;p&gt;It always irritates me whenever people ask me (or another people) this kind of question. The thing that worries me is that this kind of mindset seems to start trending in the QA industry. I am talking about over glorifying the role of automated test engineer.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;*To this day I still do not understand why is it so hard for some people to say automated test engineer instead of automation tester.  What is automation tester anyway? Are you testing an automation system or what?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In this post I will explain a bit about my journey on QA and why we should not belittle the role of testers nor overglorify the role of automated test engineers.&lt;/p&gt;

&lt;h2 id=&quot;the-personal-experience&quot;&gt;The Personal Experience&lt;/h2&gt;
&lt;p&gt;I have been working as QA Engineer for about 6 years. For that short 6 years, I have been given the chance to work for various companies and interact with QA from a lot of companies as well.&lt;/p&gt;

&lt;p&gt;On my short career on QA I have done two roles as QA Engineer:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Solely handling automated test&lt;/li&gt;
  &lt;li&gt;Testing features and handling automated test&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;During my time solely obligated to handle automated test, I feel that it is not a good fit for me since my product knowledge is limited. All the test cases are written by testers. I only need to automate these cases. It does not help that at those times the testers do not need to verify assertions I made on my automated tests. Generally it makes me feel that my impact to the development process is far from ideal.&lt;/p&gt;

&lt;p&gt;In the other hand, I consider myself to bring more value for the development process when I am automating tests and also testing features. I learn a lot about testing techniques, communicating issues, tackling obstacles on development, empathising with developers, etc.&lt;/p&gt;

&lt;p&gt;It started to make a lot of sense to me of why we need to automate &lt;strong&gt;good&lt;/strong&gt; test cases. Yes, &lt;strong&gt;good&lt;/strong&gt; test cases. &lt;em&gt;I personally do not see any point on creating thousands of automated test that will not detect any defect as early as possible.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;But do you have the time to do both? Ain‚Äôt it exhausting?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Well I would say, &lt;strong&gt;it is exhausting&lt;/strong&gt;. But it is rewarding at the same time. It made me realize that there are so much to testing rather than just test automation.&lt;/p&gt;

&lt;p&gt;I feel so lucky that I was faced early with the harsh reality: &lt;strong&gt;I  suck at testing&lt;/strong&gt;. A lot of the features that I tested turns out to have a lot of faulty on production. It made me thinking, &lt;strong&gt;&lt;em&gt;‚ÄúIf my test cases are these bad. What is the point of automating them?‚Äù&lt;/em&gt;&lt;/strong&gt;. This epiphany forces me to read, learn, and ask a lot of questions on how to test better.&lt;/p&gt;

&lt;p&gt;I personally prefer doing a hybrid of both testing features and handling automated test. It gives me the opportunity to observe and be the best of both worlds.&lt;/p&gt;

&lt;h2 id=&quot;the-trend&quot;&gt;The Trend&lt;/h2&gt;
&lt;p&gt;All of these are from my personal experience. Of course there are a lot of different cases for every company and individual. However it irritates me the most when I was faced with situations where the so called &lt;em&gt;leaders&lt;/em&gt; in QA department think less of testers compared to automated test engineer.&lt;/p&gt;

&lt;p&gt;There were instances where I saw some leaders lured testers to learn about automated test by convincing them that their salary will be better if they became automated test engineers. I think this is kind of the worst case scenario of a trend of over glorifying automated test engineer. I believe this kind of view from people who are considered to be &lt;em&gt;senior&lt;/em&gt; in QA then influence people in the industry to overglorify testers who can write automated test.&lt;/p&gt;

&lt;h2 id=&quot;the-unpopular-opinion&quot;&gt;The Unpopular Opinion&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Automated test is not a magic pill&lt;/strong&gt; 
&lt;strong&gt;&amp;amp; people who can automate is not a doctor that will immediately cure your problems.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Automated test is a tool that will complement your existing test activities. Testers who are and are not doing automated test should be treated equally. They possess different skill sets and can transfer their knowledge from one to another, forming a great testing team.&lt;/p&gt;

&lt;p&gt;I would argue that writing automated test is not on the same level of difficulty of writing production features. Do not get me wrong, automated test project should be treated with the same care. But it is only logical that hiring developers for the task is simply more efficient. Most developers can kickstart automated test in a breeze.&lt;/p&gt;

&lt;p&gt;So what makes a QA that can write automated test any special? I believe the testing skills and techniques will be the main difference that separate them. How do you acquire testing skills and techniques? By testing features don‚Äôt you think? üòâ&lt;/p&gt;

&lt;p&gt;Or if your testing team has separated testers who exclusively write test cases, don‚Äôt you see now how important too is their work?  üëÄ&lt;/p&gt;

&lt;h2 id=&quot;the-verdict&quot;&gt;The Verdict&lt;/h2&gt;
&lt;p&gt;There are a lot of more to it on testing than only test automation. There are a lot of testing techniques and variations to learn. Other than automated test, one will also need to consider say CI/CD practices. What good are automated tests if it is rarely used? Or when it is used, it never produces consistent result?&lt;/p&gt;

&lt;p&gt;For me automated test is an icing on the cake on top of good testing practices. If our testing practices suck, do not expect test automation to magically solve our problem. We need to fix our testing practices first.&lt;/p&gt;

&lt;p&gt;And one good way to start improving testing practices is to start honoring both testers and automated test engineers with the same level of respect. This way everyone understands the importance of both generating good tests and automated tests.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;If your testing scenarios sucks, what do you think the output of your automated tests will be?&lt;/strong&gt;&lt;/p&gt;</content><author><name>Raymond</name></author><category term="software testing" /><category term="automated test" /><category term="software testing" /><category term="automated test" /><summary type="html">The question I dread the most. &quot;Are you an automated test engineer or _just_ a tester?&quot; Who are you to say testing a feature thoroughly is not as valuable as automating tests?</summary></entry><entry><title type="html">Reusing Karate Tests as Performance Test</title><link href="http://localhost:4000/karate/automated%20test/performance%20test/karate-perf-test/" rel="alternate" type="text/html" title="Reusing Karate Tests as Performance Test" /><published>2020-06-23T00:00:00+07:00</published><updated>2020-06-23T00:00:00+07:00</updated><id>http://localhost:4000/karate/automated%20test/performance%20test/karate-perf-test</id><content type="html" xml:base="http://localhost:4000/karate/automated%20test/performance%20test/karate-perf-test/">&lt;h2 id=&quot;karate-tests-prep&quot;&gt;Karate Tests Prep&lt;/h2&gt;
&lt;p&gt;If you haven‚Äôt read through my article &lt;a href=&quot;https://dnomyar.dev/karate/automated%20test/karate-graphql&quot; target=&quot;_blank&quot;&gt;Powerful GraphQL Automated Test Using Karate&lt;/a&gt;, you should do that now. You will need to know how Karate test works before proceeding with this one üòâ&lt;/p&gt;

&lt;h2 id=&quot;what-is-performance-testing&quot;&gt;What is Performance Testing?&lt;/h2&gt;

&lt;p&gt;Performance testing checks the speed, response time, reliability, resource usage, scalability of a software program under their expected workload. The purpose of Performance Testing is not to find functional defects but to eliminate performance bottlenecks in the software or device.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/reuse-karate-perf/graph.jpg&quot; alt=&quot;Graph&quot; title=&quot;Graph&quot; height=&quot;50%&quot; width=&quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;sub align=&quot;center&quot;&gt;
&lt;a href=&quot;https://unsplash.com/photos/0jTZTMyGym8&quot; target=&quot;_blank&quot;&gt;Illustration&lt;/a&gt; of performance testing
&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;The focus of Performance Testing is checking a software program‚Äôs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Speed - Determines whether the application responds quickly&lt;/li&gt;
  &lt;li&gt;Scalability - Determines maximum user load the software application can handle.&lt;/li&gt;
  &lt;li&gt;Stability - Determines if the application is stable under varying loads&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;sub&gt;*Quoted from &lt;a href=&quot;https://www.guru99.com/performance-testing.html&quot; target=&quot;_blank&quot;&gt;Guru99&lt;/a&gt;&lt;sup id=&quot;fnref:guru99&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:guru99&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/sub&gt;&lt;/p&gt;

&lt;h2 id=&quot;performance-test-with-karate&quot;&gt;Performance Test With Karate&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://intuit.github.io/karate/&quot; target=&quot;_blank&quot;&gt;Karate&lt;/a&gt; provides the ability to reuse your existing karate API tests as performance test. This means that you do not need to write your performance test from scratch. All the assertions and scenarios on your existing tests can be reused!&lt;/p&gt;

&lt;p&gt;We will learn how to set up and run karate tests as performance test. All the code can be found on the &lt;a href=&quot;https://github.com/dnomyar90/football-karate-demo-graphql/tree/master/qa&quot; target=&quot;_blank&quot;&gt;repository&lt;/a&gt;. Let‚Äôs get started!&lt;/p&gt;

&lt;p&gt;For the sake of providing context, below is how the karate tests we use for performance test will look like:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@mutation
Feature: Test GraphQL Insert Player (mutation)

    Background:
        Given url baseUrl

    Scenario: Insert a player

    # Read GraphQL file
    Given def query = read('graphql/insertplayer.graphql')

    # Declare random variables for the request (in JSON format)
    And def variables = {last_name: '#(faker.randomLastName())',first_name:'#(faker.randomFirstName())', team_id:2}

    # Prepare the request
    And request { query: '#(query)', variables: '#(variables)' }
    When method POST
    Then status 200

    # Parse string as integer &amp;amp; assert with existing variable
    And match response.data.player.first_name == variables.first_name
    And match response.data.player.last_name == variables.last_name

    # Assert that there is no error
    And match response.errors == '#notpresent'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Before we proceed to write our performance test, we need to add dependecy and plugin on our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt;. There is no need to worry, for everything has been added on the &lt;a href=&quot;https://github.com/dnomyar90/football-karate-demo-graphql/blob/master/qa/pom.xml&quot; target=&quot;_blank&quot;&gt;repository&lt;/a&gt; üòÑ&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dependency:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.intuit.karate&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;karate-gatling&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;0.9.5.RC3&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Plugin:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;plugin&amp;gt;
	&amp;lt;groupId&amp;gt;net.alchim31.maven&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;scala-maven-plugin&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;4.3.1&amp;lt;/version&amp;gt;
	&amp;lt;executions&amp;gt;
		&amp;lt;execution&amp;gt;
			&amp;lt;id&amp;gt;scala-test-compile&amp;lt;/id&amp;gt;
			&amp;lt;phase&amp;gt;process-test-resources&amp;lt;/phase&amp;gt;
			&amp;lt;goals&amp;gt;
				&amp;lt;goal&amp;gt;testCompile&amp;lt;/goal&amp;gt;
			&amp;lt;/goals&amp;gt;
		&amp;lt;/execution&amp;gt;
	&amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&amp;lt;plugin&amp;gt;
	&amp;lt;groupId&amp;gt;io.gatling&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;gatling-maven-plugin&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;3.0.5&amp;lt;/version&amp;gt;
	&amp;lt;configuration&amp;gt;
		&amp;lt;simulationsFolder&amp;gt;src/test/java/simulations&amp;lt;/simulationsFolder&amp;gt;
	&amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The dependency and plugin above will enable us to write scala tests on top of existing karate features. Writing scala performance test is relatively straightforward. Below is the sample of a performance test on scala. Again no need to worry, all of these can be found on the &lt;a href=&quot;https://github.com/dnomyar90/football-karate-demo-graphql/tree/master/qa&quot; target=&quot;_blank&quot;&gt;repository&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package perftest

import com.intuit.karate.gatling.PreDef._
import io.gatling.core.Predef._
import scala.concurrent.duration._

class PerfTests extends Simulation {

  before {
    println(&quot;Perf tests started&quot;)
  }
  
  // Amount of ramp users
  val amountRampUsers: Int = 10

  // Duration of ramp
  val amountRampDuration: Int = 10

  val playersTestQuery = scenario(&quot;Query Players&quot;)
    .exec(
      karateFeature(&quot;classpath:features/FindPlayers.feature&quot;)
    )

    val playersTestMutation = scenario(&quot;Mutation Players&quot;)
    .exec(
      karateFeature(&quot;classpath:features/InsertPlayer.feature&quot;)
    )

  setUp(
    playersTestMutation.inject(rampUsers(amountRampUsers) during amountRampDuration),
    playersTestQuery.inject(rampConcurrentUsers(1) to (5) during amountRampDuration)
    ).assertions(
        global.responseTime.max.lt(500),
        global.successfulRequests.percent.gt(95)
    )

  after {
    println(&quot;Perf tests ended&quot;)
  }

} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Quite straightforward right? The scala script executes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FindPlayers&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InsertPlayer&lt;/code&gt; tests by injecting two different scenarios. For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InsertPlayer&lt;/code&gt; we inject 10 ramp users in 10 seconds duration. On the other hand for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FindPlayers&lt;/code&gt; we inject 1 to 5 concurrent ramp users in 10 seconds duration. We then assert that the maximum response time is 500ms (&lt;em&gt;The sample GraphQL apps is indeed very bad in performance&lt;/em&gt; ü§£) and success rate of endpoints are at 95%.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;What is ramp users?&lt;/p&gt;

  &lt;p&gt;What is concurrent ramp users?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Great question!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;InsertPlayer&lt;/code&gt; test, we set maximum numbers of users accessing the endpoint to 10 users in 10 seconds duration. Meanwhile for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FindPlayers&lt;/code&gt; we set concurrent users accessing the endpoint between 1 to 5 users for 10 seconds. You can find the whole documentation of gatling &lt;a href=&quot;https://gatling.io/docs/current/general/simulation_setup&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;. You can have all combinations for assertion that suits your need for performance testing. All of scala injection and assertion is quite straightforward and should not be hard to implement!&lt;/p&gt;

&lt;p&gt;We then can run the scala test we have written by running this command:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mvn clean test-compile gatling:test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Or if you have clone the &lt;a href=&quot;https://github.com/dnomyar90/football-karate-demo-graphql/&quot; target=&quot;_blank&quot;&gt;repository&lt;/a&gt;, you can just go to folder &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;qa&lt;/code&gt; and run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./run-perf-test.sh&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd qa
./run-perf-test.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;performance-test-with-karate--result&quot;&gt;Performance Test With Karate ‚Äì Result&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;The test will trigger success if all the assertion on our scala test script is fulfilled. Otherwise it will signal an error.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/reuse-karate-perf/gatling-console.png&quot; alt=&quot;Console&quot; title=&quot;Console&quot; height=&quot;90%&quot; width=&quot;90%&quot; /&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;i&gt;Console execution result&lt;/i&gt;
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Execution result of our performance test&lt;/strong&gt;. It shows all information you need in brief. The information includes request per seconds, response time percentiles, number of success and failed requests, etc. This is typically good for your overview dashboard.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/reuse-karate-perf/gatling-overview.png&quot; alt=&quot;Overview&quot; title=&quot;Overview&quot; height=&quot;90%&quot; width=&quot;90%&quot; /&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;i&gt;Overview execution result&lt;/i&gt;
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Detailed execution result of our performance test&lt;/strong&gt;. It shows the detailed information including response time percentiles, response time distribution, number of responses per second, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/reuse-karate-perf/gatling-response-time.png&quot; alt=&quot;Detailed&quot; title=&quot;Detailed&quot; height=&quot;90%&quot; width=&quot;90%&quot; /&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;i&gt;Detailed execution result&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;Alright, that‚Äôs a wrap. Thanks for reading! I hope you find this it useful and you can implement it to increase the overall quality of your product.&lt;/p&gt;

&lt;h1 id=&quot;repository&quot;&gt;&lt;a href=&quot;https://dnomyar.dev/karate/automated%20test/karate-graphql&quot; target=&quot;_blank&quot;&gt;Repository&lt;/a&gt;&lt;/h1&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:guru99&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Credit to &lt;a href=&quot;https://www.guru99.com/performance-testing.html&quot; target=&quot;_blank&quot;&gt;Guru99&lt;/a&gt;.¬†&lt;a href=&quot;#fnref:guru99&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Raymond</name></author><category term="karate" /><category term="automated test" /><category term="performance test" /><category term="karate" /><category term="automated test" /><category term="performance test" /><summary type="html">Quickly set up your first performance test with karate. No need to write your performance test from scratch. Just reuse your existing tests!</summary></entry><entry><title type="html">Powerful GraphQL Automated Test Using Karate</title><link href="http://localhost:4000/karate/automated%20test/karate-graphql/" rel="alternate" type="text/html" title="Powerful GraphQL Automated Test Using Karate" /><published>2020-06-19T00:00:00+07:00</published><updated>2020-06-19T00:00:00+07:00</updated><id>http://localhost:4000/karate/automated%20test/karate-graphql</id><content type="html" xml:base="http://localhost:4000/karate/automated%20test/karate-graphql/">&lt;h2 id=&quot;what-is-graphql&quot;&gt;What is GraphQL&lt;/h2&gt;
&lt;p&gt;Most of us probably already know about REST, as REST seems to be the go-to standard for APIs. Some of us may be thinking, what is a GraphQL? How is it different from REST? Well I was thinking the same when I first interviewed at &lt;a href=&quot;https://kumparan.com/&quot;&gt;kumparan&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I had no idea whatsoever of what GraphQL is about, let alone how to test it. But after dealing with (&lt;em&gt;testing&lt;/em&gt;) GraphQL server for 1 year, I cannot look at traditional REST API the same way again. GraphQL really solves the over-fetching problem of REST.&lt;/p&gt;

&lt;p&gt;The biggest problem with traditional REST is over-fetching. Using REST, we have to call multiple endpoints to get informations we need. I would refer to this great example from &lt;a href=&quot;https://www.howtographql.com/basics/1-graphql-is-the-better-rest/&quot;&gt;HowToGraphql&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/karate-graphql/rest.png&quot; alt=&quot;REST&quot; title=&quot;REST&quot; height=&quot;75%&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Let‚Äôs assume we need to fetch:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;An user‚Äôs name&lt;/li&gt;
  &lt;li&gt;The user‚Äôs last post‚Äôs content&lt;/li&gt;
  &lt;li&gt;The user‚Äôs last 3 followers‚Äô name&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using REST, we need to make 3 requests to get all the information we need. Those 3 requests also return some information that we not need. Things can get messy real quick especially if some of the endpoints are returning huge amount of information in a request. This is the classic problem of over-fetching in REST.&lt;/p&gt;

&lt;p&gt;Using GraphQL, we can specify all information we need to get in a single request. This is because GraphQL is using a declarative approach to fetch data. What in the world is declarative approach? Good question. Again, I will provide the great example from &lt;a href=&quot;https://www.howtographql.com/basics/1-graphql-is-the-better-rest/&quot;&gt;HowToGraphql&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/images/karate-graphql/graphql.png&quot; alt=&quot;GraphQL&quot; title=&quot;GraphQL&quot; height=&quot;75%&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, we only need to send a single query to GraphQL server in order to get information we need. We do not burden our server with multiple requests. The GraphQL server also efficiently do not fetch informations we do not request for.&lt;/p&gt;

&lt;p&gt;Yeay, now you know what GraphQL is and how does it compare to REST. Do not worry. Even if you have not, you can find a sample GraphQL application that you can toy with on my &lt;a href=&quot;https://github.com/dnomyar90/football-karate-demo-graphql&quot;&gt;repository&lt;/a&gt;. The sample application is about football players, teams, and leagues.&lt;/p&gt;

&lt;p&gt;In brief, the application contains relational data between players with their respective teams and leagues. You can fetch data of players, leagues, and teams. You can also try to insert players information.&lt;/p&gt;

&lt;p&gt;The application utilizes PostgreSQL alongside GraphQL server. No need to worry as installation should be really easy to do. I also provided a data migration, so you don‚Äôt have to setup tables manually on the database üòâ&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Below is what the application looks like:&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;query{
  players{
    id
    first_name
    last_name
    team{
      id
      name
      is_league_winner
      current_competitions
      league{
        id
        name
        continent
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By having the query above, you can get information of players and their detailed information of teams &amp;amp; leagues:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;data&quot;: {
    &quot;players&quot;: [
      {
        &quot;id&quot;: &quot;1&quot;,
        &quot;first_name&quot;: &quot;Messi&quot;,
        &quot;last_name&quot;: &quot;Lionel&quot;,
        &quot;team&quot;: {
          &quot;id&quot;: 1,
          &quot;name&quot;: &quot;Barcelona&quot;,
          &quot;is_league_winner&quot;: true,
          &quot;current_competitions&quot;: [
            &quot;Copa Del Rey&quot;,
            &quot;La Liga&quot;
          ],
          &quot;league&quot;: {
            &quot;id&quot;: 6,
            &quot;name&quot;: &quot;La Liga&quot;,
            &quot;continent&quot;: &quot;Europe&quot;
          }
        }
      },
      {
        &quot;id&quot;: &quot;2&quot;,
        &quot;first_name&quot;: &quot;Henry&quot;,
        &quot;last_name&quot;: &quot;Thierry&quot;,
        &quot;team&quot;: {
          &quot;id&quot;: 2,
          &quot;name&quot;: &quot;Arsenal&quot;,
          &quot;is_league_winner&quot;: true,
          &quot;current_competitions&quot;: [
            &quot;English Premier League&quot;,
            &quot;Carling Cup&quot;
          ],
          &quot;league&quot;: {
            &quot;id&quot;: 1,
            &quot;name&quot;: &quot;English Premier League&quot;,
            &quot;continent&quot;: &quot;Europe&quot;
          }
        }
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Okay, we have learned how to fetch information using GraphQL. But how do we test GraphQL operations? Great question.&lt;/p&gt;

&lt;p&gt;GraphQL is quite different from REST in terms of request‚Äôs data type. Most of requests and responses on REST is based on JSON or XML. GraphQL on the other hand employs a query that may look like JSON. But it is actually not JSON.&lt;/p&gt;

&lt;p&gt;After doing some research, we decided to go with &lt;a href=&quot;https://intuit.github.io/karate/&quot;&gt;Karate&lt;/a&gt;. Karate provides the ability to deal with GraphQL out of the box. At the same time, it provides what I believe to be one of (&lt;em&gt;if not&lt;/em&gt;) the most powerful assertions in the whole API testing world.&lt;/p&gt;

&lt;h2 id=&quot;karate-test-framework&quot;&gt;Karate Test Framework&lt;/h2&gt;
&lt;p&gt;Karate provides an out of the box support for GraphQL queries and mutations. Karate also supports REST, and even UI Automated Testing including desktop applications. Karate runs parallelly by default. Another very enticing feature is that we can reuse existing Karate API test scenarios as performance test. Yes, you hear it right. I will cover it in another article in the future.&lt;/p&gt;

&lt;p&gt;But if you ask me what my most favourite feature of karate is, it would be it‚Äôs insanely simple yet powerful assertion. GraphQL may be efficient and all that, but it can also gives you headache testing it. It is very likely you will encounter nested response on GraphQL applications. Based on my past experience on using &lt;a href=&quot;http://rest-assured.io/&quot;&gt;REST-Assured&lt;/a&gt;, I already expected that I will have to deal with gruesome task asserting nested data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Except that with Karate, I don‚Äôt&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I am going to give you a peek of how easy you can do request and assertion on Karate. All of the examples are available on the &lt;a href=&quot;https://github.com/dnomyar90/football-karate-demo-graphql/tree/master/qa&quot;&gt;repository&lt;/a&gt;. Alright, let‚Äôs get into it!&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Scenario: Find All Players

    # Define GraphQL query
    # In karate you can use multiline declaration

    Given text query =
    &quot;&quot;&quot;
    {
      players{
        id
        first_name
        last_name
        team{
            id
            name
            is_league_winner
            current_competitions
            league{
                id
                name
                continent
            }
        }
    }
  }
    &quot;&quot;&quot;

        # Request the query
        And request { query: '#(query)'}

        # Use method POST (GraphQL always uses POST)
        When method POST

        # Assert status code is OK
        Then status 200

        # Print response
        And print response
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As you might have noticed, Karate employs a cucumber-like syntax. It is however not cucumber, as we do not need to write a &lt;em&gt;glue&lt;/em&gt; code to translate the sentences. The example above shows you how we can even use multi-line variable on Karate. Below are the data that will be returned:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;data&quot;: {
    &quot;players&quot;: [
      {
        &quot;id&quot;: &quot;1&quot;,
        &quot;first_name&quot;: &quot;Messi&quot;,
        &quot;last_name&quot;: &quot;Lionel&quot;,
        &quot;team&quot;: {
          &quot;id&quot;: 1,
          &quot;name&quot;: &quot;Barcelona&quot;,
          &quot;is_league_winner&quot;: true,
          &quot;current_competitions&quot;: [
            &quot;Copa Del Rey&quot;,
            &quot;La Liga&quot;
          ],
          &quot;league&quot;: {
            &quot;id&quot;: 6,
            &quot;name&quot;: &quot;La Liga&quot;,
            &quot;continent&quot;: &quot;Europe&quot;
          }
        }
      },
      {
        &quot;id&quot;: &quot;2&quot;,
        &quot;first_name&quot;: &quot;Henry&quot;,
        &quot;last_name&quot;: &quot;Thierry&quot;,
        &quot;team&quot;: {
          &quot;id&quot;: 2,
          &quot;name&quot;: &quot;Arsenal&quot;,
          &quot;is_league_winner&quot;: true,
          &quot;current_competitions&quot;: [
            &quot;English Premier League&quot;,
            &quot;Carling Cup&quot;
          ],
          &quot;league&quot;: {
            &quot;id&quot;: 1,
            &quot;name&quot;: &quot;English Premier League&quot;,
            &quot;continent&quot;: &quot;Europe&quot;
          }
        }
      }
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Okay, now we head to the interesting part: &lt;strong&gt;assertion&lt;/strong&gt;. Below you can find some of assertions that you can do on Karate. Some nested assertions included.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;*Spoiler: You can do nested assertion just by one line of code on Karate&lt;/em&gt; üòÑ&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Asserting response time is less than 100ms:
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Then assert responseTime &amp;lt; 100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Asserting each record of player‚Äôs team is_league_winner is boolean:
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Then match each response.data.players[*].team.is_league_winner == '#boolean'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Asserting data of players is returned (empty array is okay):
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Then match response.data.players != '#null'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Asserting each player has a team competing in competitions:
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Then match each response.data.players[*].team.current_competitions[*] != '#null'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Asserting that there is a team competing in ‚ÄúLa Liga‚Äù competition:
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Then match response.data.players[*].team.current_competitions[*] contains &quot;La Liga&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Asserting that there is a team competing in ‚ÄúLa Liga‚Äù and ‚ÄúCopa Del Rey‚Äù competition:
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;And def competitions = [&quot;Copa Del Rey&quot;, &quot;La Liga&quot;]
Then match response.data.players[*].team.current_competitions[*] contains competitions
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Asserting that there is no team competing in ‚ÄúLa Liga‚Äù and ‚ÄúBundesliga‚Äù competition:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# This is one of karate's own style wildcards
# It might look unfamiliar. But you will get used to it in no time
And def competitions = [&quot;La Liga&quot;, &quot;Bundesliga&quot;]
Then match response.data.players[*].team.current_competitions[*] !contains '#(^competitions)'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Assert no error response is returned:
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Then match response.errors == '#notpresent'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I can go on and on, but there are simply a lot of combinations to do. I suggest you try it by yourself using examples provided on my &lt;a href=&quot;https://github.com/dnomyar90/football-karate-demo-graphql&quot;&gt;repository&lt;/a&gt;. You will be amazed on how simple yet powerful some of the assertions are in &lt;a href=&quot;https://intuit.github.io/karate/&quot;&gt;Karate&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Thanks for reading! I hope you found it useful!&lt;/p&gt;</content><author><name>Raymond</name></author><category term="karate" /><category term="automated test" /><category term="karate" /><category term="automated test" /><summary type="html">Demo of karate test framework for GraphQL application. Sample GraphQL application is provided.</summary></entry></feed>